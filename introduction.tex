\section{Introduction}

End user programmers' develop by interleaving opportunistic information foraging with writing code~\cite{brandt_two_2009}~\cite{brandt_example-centric_2010}.
As online coverage of common APIs grows~\cite{parnin_measuring_2011}, programmers increasingly use \emph{crowd documentation} like StackOverflow and blog postings.
Such documentation can be written by coders who lack interest or expertise in writing usable documentation.
Both experienced programmers~\cite{duala-ekoko_asking_2012} and end-user programmers~\cite{dorn_lost_2013}\cite{dorn_learning_2010} struggle to leverage web documentation to solve programming problems.

Decades of research on technical communication provide best practices for writing usable documentation.
In the domain of learning to use software, minimalist instruction~\cite{carroll_nurnberg_1990} recommends enabling users to start immediatedly on realistic tasks, reducing the amount of reading and other passive activity, and supporting error recognition and recovery.
Farkas introduces layered documentation as an extension to minimalist instruction that enables users from different backgrounds to benefit from the same documents by providing optional backup information for tasks like error recognition and correction~\cite{farkas_layering_1998}.

Instructions for web scraping code assumes a reader has some base literacy in Python, CSS selectors, and regular expressions.
Given the diverse backgrounds of both the audience and authors, it is impractical for the author to introduce all relevant parts of each language in detail.
As a result, today's Q\&A's and blogs lack immediate scaffolding for readers seeking clarification on unfamiliar or complex syntax.

\begin{figure}[!t]
\centering{
    \subfigure[An accelerator with an explanation and demonstration of what a CSS selctor does.]{
        \includegraphics[width=.4\textwidth]{figures/accelerator_css}
        \label{fig:accelerator_css}
    }
    \subfigure[An accelerator describing the high-level intent and low-level argument values of a \texttt{wget} command line.]{
        \includegraphics[width=.4\textwidth]{figures/accelerator_wget}
        \label{fig:accelerator_wget}
    }
    \caption{\Gls{name}-generated accelerators that enable programmers to seek in-situ help when working with wild code.  Programmers select the code they want clarification about, and view natural language descriptions and demonstrations of what the code does.}
    \label{fig:accelerators}
}

\end{figure}
To enable this scaffolded documentation, we propose routines called \emph{\Glspl{name}} that produce on-demand, context-relevant descriptions of specific programming languages, libraries, and commands.
The descriptions are \emph{on-demand} in that they can describe code found anywhere, including the browser or IDE, to provide just-in-time understanding of code.
They are also \emph{context-relevant}, describing only the syntactic elements that are present and important within a snippet.
This distinguishes these explanations from getting-started guides and reference documentation for a language.
Context relevance is defined uniquely for each \gls{name}, as we describe below.

Such explanations can describe languages like CSS selectors and regular expressions.
Each explainer is programmed with several hundred lines of code that accepts some input document, detects relevant code, and generates natural language explanations or demonstrations of the code.
We show that they can be built as standalone servers, accessible by a central addon in the programmer's browser to provide just-in-time explanations of a language, command or API anywhere on the web.
With additional effort, \glspl{name} can generate text descriptions at multiple levels of detail, which we also demonstrate.

Before proceeding, we introduce some terminology:
\begin{itemize}
\item A \emph{\gls{name}} is a routine on a web server with some language-specific rules for detecting, parse and explain source code written on a web page.
\item An \emph{accelerator} is the output of a \gls{name} for a single explainable region of code: a formatted natural language explanation or demonstration of what the code does.  Accelerators are so named because they reduce the need for programmers to spend time searching for documentation to describe unfamiliar code.
\item A \emph{code snippet} is a block of code on a page encompassed in a single DOM element --- e.g., a \texttt{<code>} or \texttt{<pre>} block --- that a programmer is taking effort to understand or reuse.
\item An \emph{explainable region} is a substring of a code snippet that a \gls{name} can parse and explain --- e.g., the term \texttt{div} in the jQuery code \texttt{\$('div').css(\{'display': 'none'\})} is an explainable region for the CSS \gls{name}.
\item The \emph{\Glspl{name} addon} is a browser extension for Firefox that automatically queries \glspl{name} for explanations and demonstrations of code, currently for CSS selectors and \texttt{wget}, that we use to show and evaluate the advantages of in-situ programming help.
\end{itemize}

Our contributions are as follows.
First, we show a need for micro-explanations by exposing unexplained languages in code snippets from popular StackOverflow questions.
Second, we introduce a framework for building a natural language explainer for describing a programming language or command line.
Third, we demonstrate the technical effort required to build \glspl{name} by building them for CSS selectors, command lines, and regular expressions.
Finally, we show through an in-lab study how \gls{name}-generated explanations can help programmers modify existing code containing CSS selectors to perform new tasks when they have no prior knowledge of selectors. 
