\section{How to build a \gls{name}}

Necessary terms: \emph{code chunk, bookmarklet, \gls{name}, explanation, language/library}

\subsection{Overview of \gls{name} Ecosystem}

A \gls{name} can be written entirely as server-side code with a lightweight bookmarklet for the browser.
From the browser side, a user downloads a \emph{\gls{name} bookmarklet} for a language or library: for example, CSS selectors.
A bookmarklet is minified line of JavaScript that stored as a bookmark and executed by selecting the bookmark.
They are used to store a users' commonly-used custom web scripts in a convenient, easy-to-access place.
When a user navigates to a tutorial page, she activates the \gls{name} by clicking on the bookmarklet.
All `explainable' instances of the language are highlighted.
When the user clicks on one of these instances, she sees a tooltip-based explanation of the code appear.
The bookmarklet can be written in several lines of JavaScript code and is the same for all \glspl{name} except for pointing to a unique server for that language or library.

Most of the work of the \gls{name} is done on a server.
When activated, the bookmarklet sends the contents of the page to a server.
The server the performs the following steps with the uploaded content:
\begin{itemize}
\item The server \emph{detects} all instances of the library or language in code sections of the uploaded content
\item It \emph{parses} detected strings of code
\item Finally, it generates explanations of this code as HTML and SVGs that can be viewed as tooltips from the browser.
\end{itemize}
We explain each of these steps in detail in the section below.

See Figure~\ref{fig:tutoron-architecture} for a diagram of the flow of information between the browser and the server.

\subsection{Components of a \gls{name}}

Describe the common underpinnings of all \glspl{name}: the detect, parse, augment pipeline.
How do we decide what to show when there are many many \glspl{name} authored by many different people for similar concepts.
We note that the pipeline may be deeper:
You run detectors for many \glspl{name} and then mediate which ones to show based on e.g, specificity, and a model of the userâ€™s knowledge.
Also, we may just punt to the user to say ``these are the explanations available for this chunk -- you decide which one you want.''

We focus on the process of building a CSS explainer \gls{name}, to concretize the implementation efforts needed to write a \gls{name}.

\subsection{Detecting Explainable Code}

\subsection{Parsing the Example}

\subsection{Producing an Explanation}

\andrew{Note: Margaret Burnett recommends personalizing suggestions and error messages with personal pronouns, a la Gidget.
Can we work this into our recommendations for writing useful adaptive explanations?}

\subsection{Design Space of Explanation Types}

\andrew{Are there also restrictions on the types of code that we can read and process?}
\andrew{Perhaps our workflow for most common wget arguments is also valid here for most common CSS selector elements.}

Talk about the design space of \glspl{name} here, then in the examples reference which type of \gls{name} each example instantiates.
